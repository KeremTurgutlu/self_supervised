# AUTOGENERATED! DO NOT EDIT! File to edit: nbs/01 - augmentations.ipynb (unless otherwise specified).

__all__ = ['RandomGaussianBlur', 'get_kornia_batch_augs', 'get_torchvision_batch_augs', 'get_fastai_batch_augs',
           'get_batch_augs', 'get_multi_aug_pipelines', 'assert_aug_pipelines']

# Cell
from fastai.vision.all import *
from kornia.augmentation import augmentation as korniatfm
import torchvision.transforms as tvtfm
import kornia

# Cell
class RandomGaussianBlur(RandTransform):
    "Randomly apply gaussian blur with probability `p` with a value of s"
    order = 11
    def __init__(self, p=0.5, s=(8,32), same_on_batch=False, **kwargs):
        store_attr()
        super().__init__(p=p, **kwargs)

    def encodes(self, x:TensorImage):
        if isinstance(self.s, tuple): s = np.random.randint(*self.s)
        if isinstance(self.s, list):  s = np.random.randint(*self.s)
        if isinstance(self.s, int):   s = self.s
        s2 = int(s/4)*2+1
        tfm = korniatfm.GaussianBlur((s2,s2),(s,s),same_on_batch=self.same_on_batch,p=1.)
        return tfm(x)

# Cell
def get_kornia_batch_augs(size,
                        rotate=True,
                        jitter=True,
                        bw=True,
                        blur=True,
                        resize_scale=(0.2, 1.0),
                        resize_ratio=(3/4, 4/3),
                        rotate_deg=30,
                        jitter_s=.6,
                        blur_s=(4,32),
                        same_on_batch=False,
                        flip_p=0.5, jitter_p=0.3, bw_p=0.3, blur_p=0.3,
                        stats=imagenet_stats,
                        cuda=default_device().type == 'cuda',
                        xtra_tfms=[]):
    "Input batch augmentations implemented in kornia"
    tfms = []
    tfms += [korniatfm.RandomResizedCrop((size, size), scale=resize_scale, ratio=resize_ratio, same_on_batch=same_on_batch)]
    tfms += [korniatfm.RandomHorizontalFlip(p=flip_p)]

    if rotate: tfms += [korniatfm.RandomRotation(rotate_deg, same_on_batch=same_on_batch)]

    if jitter: tfms += [korniatfm.ColorJitter(0.8*jitter_s, 0.8*jitter_s, 0.8*jitter_s, 0.2*jitter_s, p=jitter_p, same_on_batch=same_on_batch)]
    if bw:     tfms += [korniatfm.RandomGrayscale(p=bw_p, same_on_batch=same_on_batch)]
    if blur:   tfms += [RandomGaussianBlur(p=blur_p, s=blur_s, same_on_batch=same_on_batch)]


    if stats is not None: tfms += [Normalize.from_stats(*stats, cuda=cuda)]

    tfms += xtra_tfms
    pipe = Pipeline(tfms, split_idx = 0)
    return pipe

# Cell
def get_torchvision_batch_augs(size,
                            rotate=True,
                            jitter=True,
                            bw=True,
                            blur=True,
                            resize_scale=(0.2, 1.0),
                            resize_ratio=(3/4, 4/3),
                            rotate_deg=30,
                            jitter_s=.6,
                            blur_s=(4,32),
                            flip_p=0.5, bw_p=0.3, blur_p=0.3,
                            stats=imagenet_stats,
                            cuda=default_device().type == 'cuda',
                            xtra_tfms=[]):
    "Input batch augmentations implemented in torchvision"
    tfms = []
    tfms += [tvtfm.RandomResizedCrop((size, size), scale=resize_scale, ratio=resize_ratio)]
    tfms += [tvtfm.RandomHorizontalFlip(p=flip_p)]

    if rotate: tfms += [tvtfm.RandomRotation(rotate_deg)]

    if jitter: tfms += [tvtfm.ColorJitter(0.8*jitter_s, 0.8*jitter_s, 0.8*jitter_s, 0.2*jitter_s)]
    if bw:     tfms += [tvtfm.RandomGrayscale(p=bw_p)]
    if blur:   tfms += [RandomGaussianBlur(p=blur_p, s=blur_s)]

    tfms += xtra_tfms
    if stats is not None: tfms += [Normalize.from_stats(*stats, cuda=cuda)]

    pipe = Pipeline(tfms, split_idx = 0)
    return pipe

# Cell
def get_fastai_batch_augs(size,
                        rotate=True,
                        jitter=True,
                        bw=True,
                        blur=True,
                        min_scale=0.2,
                        resize_ratio=(3/4, 4/3),
                        max_lighting=0.2,
                        rotate_deg=30,
                        blur_s=(8,32),
                        same_on_batch=False,
                        flip_p=0.5, jitter_p=0.3, bw_p=0.3, blur_p=0.3,
                        stats=imagenet_stats,
                        cuda=default_device().type == 'cuda',
                        xtra_tfms=[]):
    "Input batch augmentations implemented in kornia"
    tfms = []
    tfms += [RandomResizedCropGPU((size, size), min_scale=min_scale, ratio=resize_ratio)]
    tfms += [Flip(p=flip_p)]

    if rotate: tfms += [Rotate(rotate_deg, batch=same_on_batch)]

    if jitter:
        tfms += [Brightness(max_lighting=max_lighting, p=jitter_p, batch=same_on_batch)]
        tfms += [Contrast(max_lighting=max_lighting, p=jitter_p, batch=same_on_batch)]
        tfms += [Hue(max_hue=max_lighting/2, p=jitter_p, batch=same_on_batch)]
        tfms += [Saturation(max_lighting=max_lighting, p=jitter_p, batch=same_on_batch)]
    if bw:     tfms += [korniatfm.RandomGrayscale(p=bw_p, same_on_batch=same_on_batch)]
    if blur:   tfms += [RandomGaussianBlur(p=blur_p, s=blur_s, same_on_batch=same_on_batch)]


    if stats is not None: tfms += [Normalize.from_stats(*stats, cuda=cuda)]

    tfms += xtra_tfms
    tfms = setup_aug_tfms(tfms)
    pipe = Pipeline(tfms, split_idx = 0)
    return pipe

# Cell
def get_batch_augs(size,
                    rotate=True,
                    jitter=True,
                    bw=True,
                    blur=True,
                    resize_scale=(0.2, 1.0),
                    resize_ratio=(3/4, 4/3),
                    rotate_deg=30,
                    jitter_s=.6,
                    blur_s=(4,32),
                    same_on_batch=False,
                    flip_p=0.5, rotate_p=0.3, jitter_p=0.3, bw_p=0.3, blur_p=0.3,
                    stats=imagenet_stats,
                    cuda=default_device().type == 'cuda',
                    xtra_tfms=[]):
    "Input batch augmentations implemented in tv+kornia+fastai"
    tfms = []
    tfms += [tvtfm.RandomResizedCrop((size, size), scale=resize_scale, ratio=resize_ratio)]
    tfms += [korniatfm.RandomHorizontalFlip(p=flip_p)]

    if rotate: tfms += [Rotate(max_deg=rotate_deg, p=rotate_p, batch=same_on_batch)]

    if jitter: tfms += [korniatfm.ColorJitter(0.8*jitter_s, 0.8*jitter_s, 0.8*jitter_s, 0.2*jitter_s, p=jitter_p, same_on_batch=same_on_batch)]
    if bw:     tfms += [korniatfm.RandomGrayscale(p=bw_p, same_on_batch=same_on_batch)]
    if blur:   tfms += [RandomGaussianBlur(p=blur_p, s=blur_s, same_on_batch=same_on_batch)]

    if stats is not None: tfms += [Normalize.from_stats(*stats, cuda=cuda)]

    tfms += xtra_tfms
    pipe = Pipeline(tfms, split_idx = 0)
    return pipe

# Cell
@delegates(get_batch_augs)
def get_multi_aug_pipelines(n, size, **kwargs): return [get_batch_augs(size, **kwargs) for i in range(n)]

# Cell
from typing import List
def assert_aug_pipelines(aug_pipelines:List[Pipeline]):
    try:    assert all(isinstance(o, Pipeline) for o in aug_pipelines)
    except: raise Exception("Each augmentation pipeline needs to be an instance of Pipeline.")
    try:    assert all(pipe.split_idx == 0 for pipe in aug_pipelines)
    except: raise Exception("Each Pipeline instance need to set to Pipeline(..., split_idx=0)")
# AUTOGENERATED! DO NOT EDIT! File to edit: nbs/01 - augmentations.ipynb (unless otherwise specified).

__all__ = ['GaussianBlur', 'RandomGaussianBlur', 'get_kornia_batch_augs', 'get_torchvision_batch_augs',
           'get_fastai_batch_augs', 'get_batch_augs']

# Cell
from fastai.vision.all import *
from kornia.augmentation import augmentation as korniatfm
import torchvision.transforms as tvtfm
import kornia

# Cell
from typing import Callable, Tuple, Union, List, Optional, Dict, cast
from kornia.filters import GaussianBlur2d
class GaussianBlur(kornia.augmentation.AugmentationBase2D):
    #https://kornia.readthedocs.io/en/latest/_modules/kornia/augmentation/augmentation.html#GaussianBlur
    # Use this until kornia 0.4.2 released
    r"""Apply gaussian blur given tensor image or a batch of tensor images randomly.

    Args:
        kernel_size (Tuple[int, int]): the size of the kernel.
        sigma (Tuple[float, float]): the standard deviation of the kernel.
        border_type (str): the padding mode to be applied before convolving.
          The expected modes are: ``'constant'``, ``'reflect'``,
          ``'replicate'`` or ``'circular'``. Default: ``'reflect'``.
        return_transform (bool): if ``True`` return the matrix describing the transformation applied to each
            input tensor. If ``False`` and the input is a tuple the applied transformation wont be concatenated.
        same_on_batch (bool): apply the same transformation across the batch. Default: False.
        p (float): probability of applying the transformation. Default value is 0.5.

    Shape:
        - Input: :math:`(C, H, W)` or :math:`(B, C, H, W)`, Optional: :math:`(B, 3, 3)`
        - Output: :math:`(B, C, H, W)`

    Note:
        Input tensor must be float and normalized into [0, 1] for the best differentiability support.
        Additionally, this function accepts another transformation tensor (:math:`(B, 3, 3)`), then the
        applied transformation will be merged int to the input transformation tensor and returned.

    Examples:
        >>> rng = torch.manual_seed(0)
        >>> input = torch.rand(1, 1, 5, 5)
        >>> blur = GaussianBlur((3, 3), (0.1, 2.0), p=1.)
        >>> blur(input)
        tensor([[[[0.6699, 0.4645, 0.3193, 0.1741, 0.1955],
                  [0.5422, 0.6657, 0.6261, 0.6527, 0.5195],
                  [0.3826, 0.2638, 0.1902, 0.1620, 0.2141],
                  [0.6329, 0.6732, 0.5634, 0.4037, 0.2049],
                  [0.8307, 0.6753, 0.7147, 0.5768, 0.7097]]]])
    """

    def __init__(self, kernel_size: Tuple[int, int],
                 sigma: Tuple[float, float],
                 border_type: str = 'reflect',
                 return_transform: bool = False,
                 same_on_batch: bool = False,
                 p: float = 0.5) -> None:
        super(GaussianBlur, self).__init__(
            p=p, return_transform=return_transform, same_on_batch=same_on_batch, p_batch=1.)
        self.transform = GaussianBlur2d(kernel_size, sigma, border_type)

    def __repr__(self) -> str:
        return self.__class__.__name__ + f"({super().__repr__()})"

    def generate_parameters(self, batch_shape: torch.Size) -> Dict[str, torch.Tensor]:
        return dict()

    def apply_transform(self, input: torch.Tensor, params: Dict[str, torch.Tensor]) -> torch.Tensor:
        return self.transform(input)

# Cell
class RandomGaussianBlur(RandTransform):
    "Randomly apply gaussian blur with probability `p` with a value of s"
    order = 11
    def __init__(self, p=0.5, s=(8,32), same_on_batch=False, **kwargs):
        store_attr()
        super().__init__(p=p, **kwargs)

    def encodes(self, x:TensorImage):
        if isinstance(self.s, tuple): s = np.random.randint(*self.s)
        if isinstance(self.s, list):  s = np.random.randint(*self.s)
        if isinstance(self.s, int):   s = self.s
        s2 = int(s/4)*2+1
        tfm = GaussianBlur((s2,s2),(s,s),same_on_batch=self.same_on_batch,p=1.)
        return tfm(x)

# Cell
def get_kornia_batch_augs(size,
                        rotate=True,
                        jitter=True,
                        bw=True,
                        blur=True,
                        resize_scale=(0.2, 1.0),
                        resize_ratio=(3/4, 4/3),
                        rotate_deg=30,
                        s=.6,
                        blur_s=(4,32),
                        same_on_batch=False,
                        flip_p=0.5, jitter_p=0.3, bw_p=0.3, blur_p=0.3,
                        stats=imagenet_stats,
                        cuda=default_device().type == 'cuda',
                        xtra_tfms=[]):
    "Input batch augmentations implemented in kornia"
    tfms = []
    tfms += [korniatfm.RandomResizedCrop((size, size), scale=resize_scale, ratio=resize_ratio, same_on_batch=same_on_batch)]
    tfms += [korniatfm.RandomHorizontalFlip(p=flip_p)]

    if rotate: tfms += [korniatfm.RandomRotation(rotate_deg, same_on_batch=same_on_batch)]

    if jitter: tfms += [korniatfm.ColorJitter(0.8*s, 0.8*s, 0.8*s, 0.2*s, p=jitter_p, same_on_batch=same_on_batch)]
    if bw:     tfms += [korniatfm.RandomGrayscale(p=bw_p, same_on_batch=same_on_batch)]
    if blur:   tfms += [RandomGaussianBlur(p=blur_p, s=blur_s, same_on_batch=same_on_batch)]


    if stats is not None: tfms += [Normalize.from_stats(*stats, cuda=cuda)]

    tfms += xtra_tfms
    pipe = Pipeline(tfms, split_idx = 0)
    return pipe

# Cell
def get_torchvision_batch_augs(size,
                            rotate=True,
                            jitter=True,
                            bw=True,
                            blur=True,
                            resize_scale=(0.2, 1.0),
                            resize_ratio=(3/4, 4/3),
                            rotate_deg=30,
                            s=.6,
                            blur_s=(4,32),
                            flip_p=0.5, bw_p=0.3, blur_p=0.3,
                            stats=imagenet_stats,
                            cuda=default_device().type == 'cuda',
                            xtra_tfms=[]):
    "Input batch augmentations implemented in torchvision"
    tfms = []
    tfms += [tvtfm.RandomResizedCrop((size, size), scale=resize_scale, ratio=resize_ratio)]
    tfms += [tvtfm.RandomHorizontalFlip(p=flip_p)]

    if rotate: tfms += [tvtfm.RandomRotation(rotate_deg)]

    if jitter: tfms += [tvtfm.ColorJitter(0.8*s, 0.8*s, 0.8*s, 0.2*s)]
    if bw:     tfms += [tvtfm.RandomGrayscale(p=bw_p)]
    if blur:   tfms += [RandomGaussianBlur(p=blur_p, s=blur_s)]

    tfms += xtra_tfms
    if stats is not None: tfms += [Normalize.from_stats(*stats, cuda=cuda)]

    pipe = Pipeline(tfms, split_idx = 0)
    return pipe

# Cell
def get_fastai_batch_augs(size,
                        rotate=True,
                        jitter=True,
                        bw=True,
                        blur=True,
                        min_scale=0.2,
                        resize_ratio=(3/4, 4/3),
                        max_lighting=0.2,
                        rotate_deg=30,
                        s=.6,
                        blur_s=(8,32),
                        same_on_batch=False,
                        flip_p=0.5, jitter_p=0.3, bw_p=0.3, blur_p=0.3,
                        stats=imagenet_stats,
                        cuda=default_device().type == 'cuda',
                        xtra_tfms=[]):
    "Input batch augmentations implemented in kornia"
    tfms = []
    tfms += [RandomResizedCropGPU((size, size), min_scale=min_scale, ratio=resize_ratio)]
    tfms += [Flip(p=flip_p)]

    if rotate: tfms += [Rotate(rotate_deg, batch=same_on_batch)]

    if jitter:
        tfms += [Brightness(max_lighting=max_lighting, p=jitter_p, batch=same_on_batch)]
        tfms += [Contrast(max_lighting=max_lighting, p=jitter_p, batch=same_on_batch)]
        tfms += [Hue(max_hue=max_lighting/2, p=jitter_p, batch=same_on_batch)]
        tfms += [Saturation(max_lighting=max_lighting, p=jitter_p, batch=same_on_batch)]
    if bw:     tfms += [korniatfm.RandomGrayscale(p=bw_p, same_on_batch=same_on_batch)]
    if blur:   tfms += [RandomGaussianBlur(p=blur_p, s=blur_s, same_on_batch=same_on_batch)]


    if stats is not None: tfms += [Normalize.from_stats(*stats, cuda=cuda)]

    tfms += xtra_tfms
    tfms = setup_aug_tfms(tfms)
    pipe = Pipeline(tfms, split_idx = 0)
    return pipe

# Cell
def get_batch_augs(size,
                    rotate=True,
                    jitter=True,
                    bw=True,
                    blur=True,
                    resize_scale=(0.2, 1.0),
                    resize_ratio=(3/4, 4/3),
                    rotate_deg=30,
                    s=.6,
                    blur_s=(4,32),
                    same_on_batch=False,
                    flip_p=0.5, rotate_p=0.3, jitter_p=0.3, bw_p=0.3, blur_p=0.3,
                    stats=imagenet_stats,
                    cuda=default_device().type == 'cuda',
                    xtra_tfms=[]):
    "Input batch augmentations implemented in tv+kornia+fastai"
    tfms = []
    tfms += [tvtfm.RandomResizedCrop((size, size), scale=resize_scale, ratio=resize_ratio)]
    tfms += [korniatfm.RandomHorizontalFlip(p=flip_p)]

    if rotate: tfms += [Rotate(max_deg=rotate_deg, p=rotate_p, batch=same_on_batch)]

    if jitter: tfms += [korniatfm.ColorJitter(0.8*s, 0.8*s, 0.8*s, 0.2*s, p=jitter_p, same_on_batch=same_on_batch)]
    if bw:     tfms += [korniatfm.RandomGrayscale(p=bw_p, same_on_batch=same_on_batch)]
    if blur:   tfms += [RandomGaussianBlur(p=blur_p, s=blur_s, same_on_batch=same_on_batch)]

    if stats is not None: tfms += [Normalize.from_stats(*stats, cuda=cuda)]

    tfms += xtra_tfms
    pipe = Pipeline(tfms, split_idx = 0)
    return pipe
# AUTOGENERATED! DO NOT EDIT! File to edit: nbs/01-augmentations.ipynb (unless otherwise specified).

__all__ = ['GaussBlur2D', 'get_kornia_batch_augs', 'get_torchvision_batch_augs', 'get_batch_augs']

# Cell
from fastai.vision.all import *
import kornia
import torchvision.transforms as tvtfm

# Cell
def _gauss_blur2d(x,s):
    "Apply gaussian_blur2d kornia filter"
    s2 = int(s/4)*2+1
    x2 = unsqueeze(x, dim=0, n=4-x.dim())
    res = kornia.filters.gaussian_blur2d(x2, (s2,s2), (s,s), 'replicate')
    return res.squeeze()

class GaussBlur2D(RandTransform):
    "Randomly apply gaussian blur with probability `p` with a value of s"
    order = 11
    def __init__(self, p=0.5, s=(8,32), batch=False, **kwargs):
        store_attr()
        super().__init__(p=p)
    def encodes(self, x:TensorImage):
        if isinstance(self.s, tuple): s = np.random.randint(*self.s)
        if isinstance(self.s, list):  s = np.random.randint(*self.s)
        if isinstance(self.s, int):   s = self.s
        return _gauss_blur2d(x,s)

# Cell
def get_kornia_batch_augs(size,
                        jitter=True,
                        bw=True,
                        blur=True,
                        resize_scale=(0.2, 1.0),
                        resize_ratio=(3/4, 4/3),
                        s=.6,
                        blur_s=(8,32),
                        same_on_batch=False,
                        stats_args=imagenet_stats,
                        xtra_tfms=[]):
    "Input batch augmentations implemented in kornia"
    tfms = []
    tfms += [kornia.augmentation.RandomResizedCrop((size, size), scale=resize_scale, ratio=resize_ratio, interpolation=2, same_on_batch=same_on_batch)]
    tfms += [kornia.augmentation.RandomHorizontalFlip(p=0.5)]

    if jitter: tfms += [kornia.augmentation.ColorJitter(0.8*s, 0.8*s, 0.8*s, 0.2*s, p=0.3, same_on_batch=same_on_batch)]
    if bw:     tfms += [kornia.augmentation.RandomGrayscale(p=0.3, same_on_batch=same_on_batch)]
    if blur:   tfms += [GaussBlur2D(p=0.3, s=blur_s)]

    if stats_args is not None: tfms += [Normalize.from_stats(*stats_args)]

    tfms += xtra_tfms
    pipe = Pipeline(tfms); pipe.split_idx = 0
    return pipe

# Cell
def get_torchvision_batch_augs(size,
                            jitter=True,
                            bw=True,
                            blur=True,
                            resize_scale=(0.2, 1.0),
                            resize_ratio=(3/4, 4/3),
                            s=.6,
                            blur_s=(8,32),
                            stats_args=imagenet_stats,
                            xtra_tfms=[]):
    "Input batch augmentations implemented in torchvision"
    tfms = []
    tfms += [tvtfm.RandomResizedCrop((size, size), scale=resize_scale, ratio=resize_ratio)]
    tfms += [tvtfm.RandomHorizontalFlip(p=0.5)]

    if jitter: tfms += [tvtfm.ColorJitter(0.8*s, 0.8*s, 0.8*s, 0.2*s)]
    if bw:     tfms += [tvtfm.RandomGrayscale(p=0.3)]
    if blur:   tfms += [GaussBlur2D(p=0.3, s=blur_s)]

    tfms += xtra_tfms
    if stats_args is not None: tfms += [Normalize.from_stats(*stats_args)]

    pipe = Pipeline(tfms); pipe.split_idx = 0
    return pipe

# Cell
def get_batch_augs(size,
                    jitter=True,
                    bw=True,
                    blur=True,
                    resize_scale=(0.2, 1.0),
                    resize_ratio=(3/4, 4/3),
                    s=.6,
                    blur_s=(8,32),
                    same_on_batch=False,
                    stats_args=imagenet_stats,
                    xtra_tfms=[]):
    tfms = []
    tfms += [tvtfm.RandomResizedCrop((size, size), scale=resize_scale, ratio=resize_ratio)]
    tfms += [kornia.augmentation.RandomHorizontalFlip(p=0.5)]

    if jitter: tfms += [kornia.augmentation.ColorJitter(0.8*s, 0.8*s, 0.8*s, 0.2*s, p=0.3, same_on_batch=same_on_batch)]
    if bw:     tfms += [kornia.augmentation.RandomGrayscale(p=0.3, same_on_batch=same_on_batch)]
    if blur:   tfms += [GaussBlur2D(p=0.3, s=blur_s)]

    if stats_args is not None: tfms += [Normalize.from_stats(*stats_args)]

    tfms += xtra_tfms
    pipe = Pipeline(tfms); pipe.split_idx = 0
    return pipe